"use strict";
/*
 * @poppinss/oauth-client
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Oauth1Client = void 0;
const querystring_1 = require("querystring");
const UrlBuilder_1 = require("../../UrlBuilder");
const HttpClient_1 = require("../../HttpClient");
const Exceptions_1 = require("../../Exceptions");
const Oauth1Signature_1 = require("./Oauth1Signature");
const utils_1 = require("../../utils");
/**
 * A generic implementation of Oauth1. One can use it directly with any
 * Oauth1.0 or Oauth1.0a server
 */
class Oauth1Client {
    constructor(options) {
        this.options = options;
        /**
         * Define the request token url. Can be overridden by config
         */
        this.requestTokenUrl = '';
        /**
         * Define the authorize url. Can be overridden by config
         */
        this.authorizeUrl = '';
        /**
         * Define the access token url. Can be overridden by config
         */
        this.accessTokenUrl = '';
    }
    /**
     * Get the signature for the request
     */
    getSignature(baseUrl, method, params, requestToken) {
        return new Oauth1Signature_1.Oauth1Signature({
            url: baseUrl,
            method: method.toUpperCase(),
            params: params,
            consumerKey: this.options.clientId,
            consumerSecret: this.options.clientSecret,
            nonce: (0, utils_1.generateRandom)(32),
            unixTimestamp: Math.floor(new Date().getTime() / 1000),
            oauthToken: requestToken && requestToken.token,
            oauthTokenSecret: requestToken && requestToken.secret,
        }).generate();
    }
    /**
     * Make a signed request to the authorization server. The request follows
     * the Oauth1 spec and generates the Authorization header using the
     * [[Oauth1Signature]] class.
     */
    async makeSignedRequest(url, method, requestToken, callback) {
        const httpClient = this.httpClient(url);
        /**
         * Invoke callback to allow configuring request
         */
        if (typeof callback === 'function') {
            callback(httpClient);
        }
        /**
         * Generate oauth header
         */
        const { oauthHeader } = this.getSignature(url, method, {
            ...httpClient.params,
            ...httpClient.oauth1Params,
            /**
             * Send request body when is urlencoded
             * https://oauth1.wp-api.org/docs/basics/Signing.html#json-data
             */
            ...(httpClient.requestType === 'urlencoded' ? httpClient.fields : {}),
        }, requestToken);
        /**
         * Set the oauth header
         */
        httpClient.header('Authorization', `OAuth ${oauthHeader}`);
        /**
         * Make HTTP request
         */
        const response = await httpClient[method]();
        return this.processClientResponse(url, httpClient, response);
    }
    /**
     * Configure the redirect request. Invoked before
     * the user callback.
     *
     * The client defaults can be removed using the `clearParam` method
     */
    configureRedirectRequest(_) { }
    /**
     * Configure the access token request. Invoked before
     * the user callback.
     *
     * The client defaults can be removed using the `clearParam` or
     * `clearOauth1Param` methods
     */
    configureAccessTokenRequest(_) { }
    /**
     * Configure the request token request. Invoked before
     * the user callback.
     *
     * The client defaults can be removed using the `clearParam` or
     * `clearOauth1Param` methods
     */
    configureRequestTokenRequest(_) { }
    /**
     * Processing the API client response. The child class can overwrite it
     * for more control
     */
    processClientResponse(_, client, response) {
        /**
         * Return json as it is when parsed response as json
         */
        if (client.responseType === 'json') {
            return response;
        }
        return (0, querystring_1.parse)(client.responseType === 'buffer' ? response.toString() : response);
    }
    /**
     * Returns the instance of the HTTP client for internal use
     */
    httpClient(url) {
        return new HttpClient_1.HttpClient(url);
    }
    /**
     * Returns the instance of the URL builder
     */
    urlBuilder(url) {
        return new UrlBuilder_1.UrlBuilder(url);
    }
    /**
     * Verify state and the input value and raise exception if different or missing
     */
    verifyState(state, inputValue) {
        if (!state || state !== inputValue) {
            throw Exceptions_1.OauthException.stateMisMatch();
        }
    }
    /**
     * Returns the oauth token and secret for the upcoming requests
     */
    async getRequestToken(callback) {
        const requestTokenUrl = this.options.requestTokenUrl || this.requestTokenUrl;
        if (!requestTokenUrl) {
            throw new utils_1.Exception('Cannot get requestToken without "requestTokenUrl"');
        }
        const { oauth_token: oauthToken, oauth_token_secret: oauthTokenSecret, ...parsed } = await this.makeSignedRequest(requestTokenUrl, 'post', undefined, (request) => {
            request.oauth1Param('oauth_callback', this.options.callbackUrl);
            this.configureRequestTokenRequest(request);
            if (typeof callback === 'function') {
                callback(request);
            }
        });
        /**
         * We expect the response to have "oauth_token" and "oauth_token_secret"
         */
        if (!oauthToken || !oauthTokenSecret) {
            throw Exceptions_1.OauthException.missingTokenAndSecret(parsed);
        }
        return {
            token: oauthToken,
            secret: oauthTokenSecret,
            ...parsed,
        };
    }
    /**
     * Returns the redirect url for redirecting the user. We don't pre-define
     * any params here. However, one must define the "oauth_token" param
     * by passing a callback.
     *
     * ```ts
     * client.getRedirectUrl((request) => {
     *   request.param('oauth_token', value)
     * })
     * ```
     */
    getRedirectUrl(callback) {
        const authorizeUrl = this.options.authorizeUrl || this.authorizeUrl;
        if (!authorizeUrl) {
            throw new utils_1.Exception('Cannot make redirect url without "authorizeUrl"');
        }
        const urlBuilder = this.urlBuilder(authorizeUrl);
        this.configureRedirectRequest(urlBuilder);
        /**
         * Invoke callback when defined. This is the place where one can configure
         * the request query params
         */
        if (typeof callback === 'function') {
            callback(urlBuilder);
        }
        return urlBuilder.makeUrl();
    }
    /**
     * Get the access token from the oauth_verifier code. One must define
     * the "oauth_verifier" code using the callback input.
     *
     * ```ts
     * client.getAccessToken({ token, secret }, (request) => {
     *   request.oauth1Param('oauth_verifier', verifierValue)
     * })
     * ```
     */
    async getAccessToken(requestToken, callback) {
        /**
         * Even though the spec allows to generate access token without the "oauthTokenSecret".
         * We enforce both the "oauthToken" and "oauthTokenSecret" to exist. This ensures
         * better security
         */
        if (!requestToken.token) {
            throw new Error('"getAccessToken" expects "requestToken.token" as the first argument');
        }
        if (!requestToken.secret) {
            throw new Error('"getAccessToken" expects "requestToken.secret" as the first argument');
        }
        const accessTokenUrl = this.options.accessTokenUrl || this.accessTokenUrl;
        if (!accessTokenUrl) {
            throw new utils_1.Exception('Cannot get access token without "accessTokenUrl"');
        }
        /**
         * Make signed request.
         */
        const { oauth_token: accessOauthToken, oauth_token_secret: accessOauthTokenSecret, ...parsed } = await this.makeSignedRequest(accessTokenUrl, 'post', requestToken, (request) => {
            this.configureAccessTokenRequest(request);
            if (typeof callback === 'function') {
                callback(request);
            }
        });
        /**
         * We expect the response to have "oauth_token" and "oauth_token_secret"
         */
        if (!accessOauthToken || !accessOauthTokenSecret) {
            throw Exceptions_1.OauthException.missingTokenAndSecret(parsed);
        }
        return {
            token: accessOauthToken,
            secret: accessOauthTokenSecret,
            ...parsed,
        };
    }
}
exports.Oauth1Client = Oauth1Client;
